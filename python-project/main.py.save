import subprocess

import os
import telebot
from telebot import types
import yt_dlp
from download_video import  download_video
from storage_for_links import load_data
from storage_for_resolutions_and_sizes import load_resolution_data

data = load_data()
resolution_data = load_resolution_data()
bot_data = {}

BOT_TOKEN = os.environ.get('BOT_TOKEN')

#bot = telebot.TeleBot(BOT_TOKEN)

bot = telebot.Telebot(
    BOT_TOKEN,
    base_url='http://localhost:8081/bot',
    base_file_url='http://localhost:8081/file/bot'
)

@bot.message_handler(commands=['start'])
def send_welcome(message):
	bot.reply_to(message, "Welcome! The bot is ready to present you relevant lecture.")

@bot.message_handler(commands=['lecture'])
def ask_for_course(message):
    markup = types.ReplyKeyboardMarkup(one_time_keyboard=True)
    for course in data.keys():
        markup.add(course)
    bot.send_message(message.chat.id, "Select a course:", reply_markup=markup)

@bot.message_handler(func=lambda m: m.text in data.keys())
def ask_for_term(message):
    selected_course = message.text
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for term in data[selected_course].keys():
        markup.add(term)
    bot.send_message(message.chat.id, f"Selected: {selected_course}\nChoose term:", reply_markup=markup)

@bot.message_handler(func=lambda m: any(m.text in data[course] for course in data))
def ask_for_subject(message):
    # Find which course this term belongs to
    for course in data:
        if message.text in data[course]:
            selected_course = course
            selected_term = message.text
            break
    
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for subject in data[selected_course][selected_term].keys():
        markup.add(subject)
    bot.send_message(message.chat.id, f"Selected: {selected_course} - {selected_term}\nChoose subject:", reply_markup=markup)

@bot.message_handler(func=lambda m: any(m.text in data[course][term] 
                                     for course in data 
                                     for term in data[course]))
def ask_for_title(message):
    # Find which course and term this subject belongs to
    for course in data:
        for term in data[course]:
            if message.text in data[course][term]:
                selected_course = course
                selected_term = term
                selected_subject = message.text
                break
    
    markup = types.ReplyKeyboardMarkup(resize_keyboard=True, one_time_keyboard=True)
    for topic in data[selected_course][selected_term][selected_subject].keys():
        markup.add(topic)
    bot.send_message(message.chat.id, 
                    f"Selected: {selected_course} - {selected_term}  - {selected_subject}\nChoose topic:", 
                    reply_markup=markup)

@bot.message_handler(func=lambda m: any(m.text in data[course][term][subject] 
                                      for course in data 
                                      for term in data[course] 
                                      for subject in data[course][term]))
def video_request(message):
    try:
        # Find which course, term and subject this topic belongs to
        for course in data:
            for term in data[course]:
                for subject in data[course][term]:
                    if message.text in data[course][term][subject]:
                        selected_course = course
                        selected_term = term
                        selected_subject = subject
                        selected_topic = message.text
                        url = data[course][term][subject][message.text]
                        break
        
        topic = selected_topic
        
        resolutions_with_sizes = []
        for i in resolution_data[selected_course][selected_term][selected_subject][selected_topic]:
            resolution = i["resolution"]
            file_size = i["filesize_mb"]
            resolutions_with_sizes.append((resolution, file_size))

        markup = types.InlineKeyboardMarkup()
        for res, size_mb in resolutions_with_sizes:
            if size_mb == 0:
                label = f"{res}p (Size unknown)"
            else:
                label = f"{res}p ({size_mb:.1f} MB)"
            markup.add(types.InlineKeyboardButton(label, callback_data=f"dl_{res}"))
        
        # Store context in memory instead
        user_id = message.from_user.id
        bot_data[user_id] = {  # Use a dict to store temp data
            'url': url,
            'course': selected_course,
            'term': selected_term,
            'subject': selected_subject,            
            'topic': selected_topic
        }
        
        bot.send_message(message.chat.id, f"üìπ {topic}", reply_markup=markup)
            
    
    except Exception as e:
        bot.reply_to(message, f"‚ùå Error: {str(e)}")

@bot.callback_query_handler(func=lambda call: call.data.startswith('dl_'))
def send_video_file(call):
    try:
        # Parse all parameters from callback data
        user_id = call.from_user.id
        context = bot_data.get(user_id, {})
        
        if not context:
            return bot.answer_callback_query(call.id, "Session expired!")
        
        resolution = int(call.data.split('_')[1])
        url = context['url']      
        
        bot.answer_callback_query(call.id, "‚è≥ Downloading...")
        format_spec = f"bestvideo[height<={resolution}]+bestaudio/best[height<={resolution}]"

        try:
            video_path = download_video(url, format_spec)
        except Exception as e:
            return bot.send_message(call.message.chat.id, f"‚ùå Download failed: {str(e)}")

        file_size_mb = os.path.getsize(video_path) / (1024 * 1024)
        if file_size_mb > 50:
            compressed_path = video_path.replace(".mp4", "_compressed.mp4")
            
            # FFmpeg command: Compress with H.265 (libx265) at CRF 28
            command = [
                'ffmpeg',
                '-i', video_path,          # Input file
                '-vcodec', 'libx265',      # Use H.265 codec
                '-crf', '28',              # Balanced quality/size
                '-preset', 'fast',         # Faster compression
                '-tag:v', 'hvc1',          # Improve compatibility
                compressed_path            # Output file
            ]
            
            # Run FFmpeg
            subprocess.run(command, check=True)
            
            # Update paths and clean up original
            os.remove(video_path)          # Delete original
            video_path = compressed_path    # Use compressed version
            file_size_mb = os.path.getsize(video_path) / (1024 * 1024)

        course = bot_data[user_id]['course']
        term = bot_data[user_id]['term']
        subject = bot_data[user_id]['subject']
        topic = bot_data[user_id]['topic']
    
        caption = (f"üìö *Course:* {course}\n"
                  f"üìÖ *Term:* {term}\n"
                  f"üßë‚Äçüè´ *Subject:* {subject}\n"
                  f"üìπ *Topic:* {topic}\n"
                  f"üñ• *Quality:* {resolution}\n")  

        bot.send_message(call.message.chat.id, f"Uploading file ({file_size_mb:.1f} MB)... Please wait.")        

        if file_size_mb <= 50:
            with open(video_path, 'rb') as f:
                bot.send_video(call.message.chat.id, f, caption=caption, parse_mode='Markdown', timeout=6000)
        elif file_size_mb <= 2000:
            with open(video_path, 'rb') as f:
                bot.send_document(call.message.chat.id, f, caption=caption, parse_mode='Markdown', timeout=6000, visible_file_name=f"{context['topic']}_{resolution}p.mp4")
        else:
            bot.send_video(call.message.chat.id, "File size exceeds Telegram's 2GB limit.")
    
        os.remove(video_path)    
    
    except Exception as e:
        bot.send_message(call.message.chat.id, f"üî• Failed: {str(e)}")

# --- Run Bot ---
if __name__ == '__main__':
    print("Bot is running...")
    bot.infinity_polling()
